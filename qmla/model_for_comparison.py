import numpy as np
import scipy as sp
import os
import time
import copy

import qinfer as qi
import redis
import pickle

import qmla.redis_settings
import qmla.logging
import qmla.get_growth_rule
import qmla.database_framework

pickle.HIGHEST_PROTOCOL = 4

__all__ = [
    'ModelInstanceForComparison'
]

class ModelInstanceForComparison():
    """
    Model instances used for Bayes factor comparisons. 

    When Bayes factors are calculated remotely (ie on RQ workers),
    they require SMCUpdaters etc to do calculations.
    This class captures the minimum required to enable these calculations.
    After learning, important data from :class:`~qmla.ModelInstanceForLearning`
    is stored on the redis database. 
    This class unpickles the useful information and generates new 
    instances of the updater etc. to use in the comparison calculations.

    :param int model_id: ID of the model to study
    :param qid: ID of the QMLA instance
    :param dict qmla_core_info_database: essential details about the QMLA 
        instance needed to learn/compare models. 
        If None, this is retrieved instead from the redis database. 
    :param dict learned_model_info: result of learning, generated by 
        :meth:`~qmla.ModelInstanceForLearning.learned_info_dict`. 
    :param str host_name: name of host server on which redis database exists.
    :param int port_number: port number unique to this QMLA instance on redis database
    :param str log_file: path of QMLA instance's log file.

    """

    def __init__(
        self,
        model_id,
        qid,
        qmla_core_info_database=None,
        learned_model_info=None,
        host_name='localhost',
        port_number=6379,
        log_file='QMD_log.log',
    ):
        self.log_file = log_file
        self.qmla_id = qid
        self.model_id = model_id

        # Get essential data
        if qmla_core_info_database is None:
            redis_databases = qmla.redis_settings.get_redis_databases_by_qmla_id(
                host_name,
                port_number,
                qid
            )
            qmla_core_info_database = redis_databases['qmla_core_info_database']
            qmla_core_info_dict = pickle.loads(qmla_core_info_database.get('qmla_settings'))
            self.probes_system = pickle.loads(qmla_core_info_database['ProbeDict'])
            self.probes_simulator = pickle.loads(qmla_core_info_database['SimProbeDict'])
        else: 
            qmla_core_info_dict = qmla_core_info_database.get('qmla_settings')
            self.probes_system = qmla_core_info_database['ProbeDict']
            self.probes_simulator = qmla_core_info_database['SimProbeDict']

        # Assign attributes based on core data
        self.num_particles = qmla_core_info_dict['num_particles']
        self.probe_number = qmla_core_info_dict['num_probes']
        self.true_model_constituent_operators = qmla_core_info_dict['true_oplist']
        self.true_model_params = qmla_core_info_dict['true_model_terms_params']
        self.true_model_name = qmla_core_info_dict['true_name']
        self.true_param_dict = qmla_core_info_dict['true_param_dict']
        self.experimental_measurements = qmla_core_info_dict['experimental_measurements']
        self.experimental_measurement_times = qmla_core_info_dict['experimental_measurement_times']
        self.results_directory = qmla_core_info_dict['results_directory']
        
        if learned_model_info is None:
            # Get data specific to this model, learned elsewhere and stored on redis database
            try:
                redis_databases = qmla.redis_settings.get_redis_databases_by_qmla_id(
                    host_name,
                    port_number,
                    qid
                )
                learned_models_info_db = redis_databases['learned_models_info_db']
            except: 
                print("Unable to retrieve redis database.")
                raise 

            model_id_str = str(float(model_id))
            try:
                learned_model_info = pickle.loads(
                    learned_models_info_db.get(model_id_str),
                    encoding='latin1'
                )
            except BaseException:
                learned_model_info = pickle.loads(
                    learned_models_info_db.get(model_id_str)
                )

        # Assign parameters from model learned info, retrieved from database
        self.model_name = learned_model_info['name']
        self.times_learned_over = learned_model_info['times_learned_over']
        self.final_learned_params = learned_model_info['final_learned_params']        
        self.growth_rule_of_this_model = learned_model_info['growth_rule_of_this_model']
        self.posterior_marginal = learned_model_info['posterior_marginal']
        self.model_normalization_record = learned_model_info['model_normalization_record']
        self.log_total_likelihood = learned_model_info['log_total_likelihood']
        self.estimated_mean_params = learned_model_info['estimated_mean_params']
        self.qhl_final_param_estimates = learned_model_info['qhl_final_param_estimates']
        self.qhl_final_param_uncertainties = learned_model_info['qhl_final_param_uncertainties']
        self.covariance_mtx_final = learned_model_info['covariance_mtx_final']

        # Process data from learned info
        if self.model_name == self.true_model_name: 
            self.is_true_model = True
            self.log_print(["This is the true model for comparison."])
        else:
            self.is_true_model = False
        op = qmla.database_framework.Operator(self.model_name)
        self.model_terms_matrices = op.constituents_operators
        self.model_terms_parameters_final = np.array(self.final_learned_params)
        self.growth_class = qmla.get_growth_rule.get_growth_generator_class(
            growth_generation_rule=self.growth_rule_of_this_model,
            log_file=self.log_file
        )

        # New instances of model and updater used by QInfer
        self.log_print(["Getting QInfer model"])
        self.qinfer_model = self.growth_class.qinfer_model(
            model_name=self.model_name,
            modelparams=self.model_terms_parameters_final,
            oplist=self.model_terms_matrices,
            true_oplist=self.true_model_constituent_operators,
            truename=self.true_model_name,
            trueparams=self.true_model_params,
            true_param_dict = self.true_param_dict, 
            num_probes=self.probe_number,
            probe_dict=self.probes_system,
            sim_probe_dict=self.probes_simulator,
            growth_generation_rule=self.growth_rule_of_this_model,
            experimental_measurements=self.experimental_measurements,
            experimental_measurement_times=self.experimental_measurement_times,
            log_file=self.log_file,
        )

        self.reconstruct_updater = True # optionally just load it
        time_s = time.time()
        if self.reconstruct_updater:
            # reconstruct the updater from results of learning
            posterior_distribution = qi.MultivariateNormalDistribution(
                self.estimated_mean_params,
                self.covariance_mtx_final
            )

            num_particles_for_bf = max(
                5, 
                int(self.growth_class.fraction_particles_for_bf * self.num_particles)
            ) # this allows the growth rule to use less particles for the comparison stage

            self.qinfer_updater = qi.SMCUpdater(
                model=self.qinfer_model,
                n_particles=num_particles_for_bf,
                prior=posterior_distribution,
                resample_thresh = self.growth_class.qinfer_resampler_threshold,
                resampler = qi.LiuWestResampler(
                    a = self.growth_class.qinfer_resampler_a
                ),
            )
            self.qinfer_updater._normalization_record = self.model_normalization_record
            self.qinfer_updater._log_total_likelihood = self.log_total_likelihood
        else:
            # Not currently pickling the updater -- can be done in ModelInstanceForLearning.learned_info_dict()
            self.qinfer_updater = pickle.loads(
                learned_model_info['updater']
            )

        # Delete extra data now that everything useful is extracted
        del qmla_core_info_dict, learned_model_info

    ##########
    # Section: Utilities
    ##########

    def log_print(
        self,
        to_print_list
    ):
        r"""Wrapper for :func:`~qmla.print_to_log`"""
        qmla.logging.print_to_log(
            to_print_list=to_print_list,
            log_file=self.log_file,
            log_identifier='ModelForComparison {}'.format(self.model_id)
        )